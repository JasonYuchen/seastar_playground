//
// Created by jason on 2021/9/21.
//

#include "segment.hh"

#include <memory>

#include <seastar/core/reactor.hh>

#include "protocol/serializer.hh"
#include "storage/storage.hh"
#include "util/endian.hh"

using namespace seastar;
using namespace std;

namespace rafter::storage {

future<unique_ptr<segment>> segment::open(
    filesystem::path filepath, bool existing) {

  // TODO: tune seastar::file_open_options
  l.debug("open segment:{}, existing:{}",
          filepath.string(), existing);
  auto s = make_unique<segment>();
  s->_filepath = std::move(filepath);
  s->_file = co_await open_file_dma(
      s->_filepath.string(),
      existing ? (open_flags::rw) : (open_flags::create | open_flags::rw));
  s->_tail.reserve(s->_file.memory_dma_alignment());
  co_return s;
}

uint64_t segment::bytes() const noexcept {
  return _bytes;
}

future<uint64_t> segment::append(const protocol::update& update) {
  // TODO(jason): refine this routine with new fragmented_temporary_buffer

  util::fragmented_temporary_buffer buffer(0, _file.memory_dma_alignment());
  auto out_stream = buffer.as_ostream();
  uint64_t written_bytes = _tail.size();
  out_stream.write(_tail);
  _tail.clear();
  written_bytes += protocol::serialize(update, out_stream);
  out_stream.remove_suffix_to_fit();
  assert(buffer.bytes() == written_bytes);

  for (auto it : buffer) {
    assert(_aligned_pos % _file.disk_write_dma_alignment() == 0);
    auto bytes = co_await _file.dma_write(_aligned_pos, it.data(), it.size());
    if (bytes < it.size()) {
      // TODO: throw short_write?
    }
    auto aligned_bytes = align_down(bytes, _file.disk_write_dma_alignment());
    _aligned_pos += aligned_bytes;
    if (aligned_bytes < bytes) {
      // should only occur once in the last iterator
      _tail.append(it.data() + aligned_bytes, bytes - aligned_bytes);
    }
  }

  assert(_bytes + written_bytes == _aligned_pos + _tail.size());
  _bytes = _aligned_pos + _tail.size();
  co_return _bytes;
}

future<protocol::update> segment::query(const index::entry& entry) const {
  if (entry.offset + entry.length > _bytes) {
    l.error("query out of range, offset:{} + length:{} > size:{} of segment:{}",
            entry.offset, entry.length, _bytes, _filepath.string());
    // TODO: refine exception type
    co_return coroutine::make_exception(std::out_of_range("segment::query"));
  }
  // TODO: tune file stream options
  auto file_in_stream = seastar::make_file_input_stream(_file, entry.offset);
  auto buffer = co_await util::fragmented_temporary_buffer::from_stream_exactly(
      file_in_stream, entry.length);
  auto in_stream = buffer.as_istream();
  protocol::update update;
  auto read_bytes = protocol::deserialize(update, in_stream);
  if (read_bytes != entry.length) {
    l.error("inconsistent length, expect:{}, actual:{}",
            entry.length, read_bytes);
    co_return coroutine::make_exception(std::out_of_range("segment::query"));
  }
  co_return update;
}

future<> segment::sync() {
  co_return co_await _file.flush();
}

future<vector<index::entry>> segment::generate_index() const {

  // TODO(jason): refine this routine with new fragmented_temporary_buffer

  auto filename = _filepath.filename().string();
  auto shard_id = std::stoull(filename.substr(0, 3));
  auto filename_id = std::stoull(filename.substr(3));
  if (shard_id != seastar::this_shard_id()) {
    l.error("parsing segment:{} generated by shard:{} in shard:{}",
            _filepath.string(), shard_id, seastar::this_shard_id());
    // TODO: refine exception type
    co_return coroutine::make_exception(
        std::runtime_error("segment::generate_index"));
  }

  l.debug("generate index for segment:{}", _filepath.string());
  if (_bytes == 0) {
    co_return vector<index::entry>{};
  }
  // TODO: tune file stream options
  uint64_t pos = 0;
  auto in_stream = seastar::make_file_input_stream(_file, pos);
  vector<index::entry> indexes;
  while (true) {
    try {
      // TODO: index::entry only need some metadata from update, avoid parsing
      //  the whole data
      protocol::update update;
      auto read_bytes = co_await protocol::deserialize_meta(update, in_stream);
      if (read_bytes == 0) {
        break;
      }
      auto&& entry = indexes.emplace_back();
      // TODO: determine index type
      entry.type = index::entry::type::normal;
      entry.id = update.group_id;
      entry.first_index = update.first_index;
      entry.last_index = update.last_index;
      entry.filename = filename_id;
      entry.offset = pos;
      entry.length = read_bytes;
      pos += read_bytes;
    } catch (std::exception &e) {
      // TODO: refine exception type
      l.warn("corrupted data found in segment:{}, offset:{}",
             _filepath.string(), pos);
      break;
    }
  }
  co_return indexes;
}

}  // namespace rafter::storage
